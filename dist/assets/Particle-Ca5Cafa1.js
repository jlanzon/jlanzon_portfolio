import{a3 as O,a4 as q,a5 as N,$ as G,H as R,a6 as $,s as B,Z as J,b as W,E as j,L as K,F as Q,a7 as U,W as X,a8 as A,N as v,q as Y,a9 as tt,m as it,f as L,J as et}from"./index-CfC3QUvt.js";import{l as st,I as ot}from"./Container-CYE_Xo7N.js";import{g as at}from"./CanvasUtils-CBGl4Zj8.js";import"./OptionsColor-DyM3QIml.js";import"./ValueWithRandom-RnF4-S2J.js";import"./Ranges-Cr7P48sb.js";const D=0,w=2,z=.5,nt=2;function rt(f,s,a,t){const e=s.options[f];if(e)return L({close:s.close,fill:s.fill},v(e,a,t))}function lt(f,s,a,t){const e=s.options[f];if(e)return L({close:s.close,fill:s.fill},v(e,a,t))}function H(f){if(!et(f.outMode,f.checkModes))return;const s=f.radius*w;f.coord>f.maxCoord-s?f.setCb(-f.radius):f.coord<s&&f.setCb(f.radius)}class gt{constructor(s,a){this.container=a,this._calcPosition=(t,e,i,r=D)=>{for(const[,g]of t.plugins){const h=g.particlePosition!==void 0?g.particlePosition(e,this):void 0;if(h)return O.create(h.x,h.y,i)}const l=t.canvas.size,n=q({size:l,position:e}),o=O.create(n.x,n.y,i),b=this.getRadius(),u=this.options.move.outModes,y=g=>{H({outMode:g,checkModes:["bounce"],coord:o.x,maxCoord:t.canvas.size.width,setCb:h=>o.x+=h,radius:b})},C=g=>{H({outMode:g,checkModes:["bounce"],coord:o.y,maxCoord:t.canvas.size.height,setCb:h=>o.y+=h,radius:b})};return y(u.left??u.default),y(u.right??u.default),C(u.top??u.default),C(u.bottom??u.default),this._checkOverlap(o,r)?this._calcPosition(t,void 0,i,r+1):o},this._calculateVelocity=()=>{const t=N(this.direction),e=t.copy(),i=this.options.move;if(i.direction==="inside"||i.direction==="outside")return e;const r=G(R(i.angle.value)),l=G(R(i.angle.offset)),n={left:l-r*z,right:l+r*z};return i.straight||(e.angle+=$(B(n.left,n.right))),i.random&&typeof i.speed=="number"&&(e.length*=J()),e},this._checkOverlap=(t,e=D)=>{const i=this.options.collisions,r=this.getRadius();if(!i.enable)return!1;const l=i.overlap;if(l.enable)return!1;const n=l.retries;if(n>=0&&e>n)throw new Error(`${W} particle is overlapping and can't be placed`);return!!this.container.particles.find(b=>j(t,b.position)<r+b.getRadius())},this._getRollColor=t=>{if(!t||!this.roll||!this.backColor&&!this.roll.alter)return t;const e=1,i=0,r=this.roll.horizontal&&this.roll.vertical?w*e:e,l=this.roll.horizontal?Math.PI*z:i;return Math.floor(((this.roll.angle??i)+l)/(Math.PI/r))%w?this.backColor?this.backColor:this.roll.alter?at(t,this.roll.alter.type,this.roll.alter.value):t:t},this._initPosition=t=>{const e=this.container,i=R(this.options.zIndex.value),r=0;this.position=this._calcPosition(e,t,K(i,r,e.zLayers)),this.initialPosition=this.position.copy();const l=e.canvas.size,n=0;switch(this.moveCenter={...Q(this.options.move.center,l),radius:this.options.move.center.radius??n,mode:this.options.move.center.mode??"percent"},this.direction=U(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside";break}this.offset=X.origin},this._engine=s}destroy(s){var i,r,l;if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const a=this.container,t=this.pathGenerator,e=a.shapeDrawers.get(this.shape);(i=e==null?void 0:e.particleDestroy)==null||i.call(e,this);for(const[,n]of a.plugins)(r=n.particleDestroyed)==null||r.call(n,this,s);for(const n of a.particles.updaters)(l=n.particleDestroyed)==null||l.call(n,this,s);t==null||t.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(s){const a=this.container,t=a.canvas;for(const[,e]of a.plugins)await t.drawParticlePlugin(e,this,s);await t.drawParticle(this,s)}getFillColor(){return this._getRollColor(this.bubble.color??A(this.color))}getMass(){return this.getRadius()**nt*Math.PI*z}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??A(this.strokeColor))}async init(s,a,t,e){var V,F,I,M,E,T;const i=this.container,r=this._engine;this.id=s,this.group=e,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const l=i.retina.pixelRatio,n=i.actualOptions,o=st(this._engine,i,n.particles),b=o.effect.type,u=o.shape.type,{reduceDuplicates:y}=o;this.effect=v(b,this.id,y),this.shape=v(u,this.id,y);const C=o.effect,g=o.shape;if(t){if((V=t.effect)!=null&&V.type){const d=t.effect.type,P=v(d,this.id,y);P&&(this.effect=P,C.load(t.effect))}if((F=t.shape)!=null&&F.type){const d=t.shape.type,P=v(d,this.id,y);P&&(this.shape=P,g.load(t.shape))}}this.effectData=rt(this.effect,C,this.id,y),this.shapeData=lt(this.shape,g,this.id,y),o.load(t);const h=this.effectData;h&&o.load(h.particles);const m=this.shapeData;m&&o.load(m.particles);const _=new ot(r,i);_.load(i.actualOptions.interactivity),_.load(o.interactivity),this.interactivity=_,this.effectFill=(h==null?void 0:h.fill)??o.effect.fill,this.effectClose=(h==null?void 0:h.close)??o.effect.close,this.shapeFill=(m==null?void 0:m.fill)??o.shape.fill,this.shapeClose=(m==null?void 0:m.close)??o.shape.close,this.options=o;const x=this.options.move.path;this.pathDelay=R(x.delay.value)*Y,x.generator&&(this.pathGenerator=this._engine.getPathGenerator(x.generator),this.pathGenerator&&i.addPath(x.generator,this.pathGenerator)&&await this.pathGenerator.init(i)),i.retina.initParticle(this),this.size=tt(this.options.size,l),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(a),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy();const Z=1;this.moveDecay=Z-R(this.options.move.decay);const k=i.particles;k.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/i.zLayers,this.sides=24;let p=i.effectDrawers.get(this.effect);p||(p=this._engine.getEffectDrawer(this.effect),p&&i.effectDrawers.set(this.effect,p)),p!=null&&p.loadEffect&&await p.loadEffect(this);let c=i.shapeDrawers.get(this.shape);c||(c=this._engine.getShapeDrawer(this.shape),c&&i.shapeDrawers.set(this.shape,c)),c!=null&&c.loadShape&&await c.loadShape(this);const S=c==null?void 0:c.getSidesCount;S&&(this.sides=S(this)),this.spawning=!1,this.shadowColor=it(this.options.shadow.color);for(const d of k.updaters)await d.init(this);for(const d of k.movers)await((I=d.init)==null?void 0:I.call(d,this));await((M=p==null?void 0:p.particleInit)==null?void 0:M.call(p,i,this)),await((E=c==null?void 0:c.particleInit)==null?void 0:E.call(c,i,this));for(const[,d]of i.plugins)(T=d.particleCreated)==null||T.call(d,this)}isInsideCanvas(){const s=this.getRadius(),a=this.container.canvas.size,t=this.position;return t.x>=-s&&t.y>=-s&&t.y<=a.height+s&&t.x<=a.width+s}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){var s;for(const a of this.container.particles.updaters)(s=a.reset)==null||s.call(a,this)}}export{gt as Particle};
